#pragma enable_d3d11_debug_symbols

#pragma kernel ScatterGrass

struct PerInst
{
    float3 position;
    float rotationXY;
};

cbuffer ConstBuffer : register(b0)
{
    float4 TerrainBounds;
    float TerrainHeight;
}

Texture2D<float4> HeightMapTexture : register(t0);
Texture2D<float4> OccupancyTexture : register(t1);

SamplerState samplerHeightMapTexture : register(s0);
SamplerState samplerOccupancyTexture : register(s1);

StructuredBuffer<int2> visibleParcels : register(t2);
StructuredBuffer<uint> visibleParcelCount : register(t3);

RWStructuredBuffer<PerInst> instances : register(u0);

inline uint hash_int(uint x)
{
    x ^= x >> 16;
    x *= 0x7feb352du;
    x ^= x >> 15;
    x *= 0x846ca68bu;
    x ^= x >> 16;
    return x;
}

// 2D integer hash
inline uint hash_int2(int2 p)
{
    // Use large primes to avoid correlation
    uint h = (uint)p.x * 73856093u + (uint)p.y * 19349663u;
    return hash_int(h);
}

// Convert integer hash to float in [0,1] range: ~1 ALU
inline half hash_int_to_float(int2 p)
{
    uint h = hash_int2(p);
    return (half)h * (1.0f / 4294967296.0f); // Convert to [0,1]
}

inline half PackTwoBytesIntoHalf(uint value1, uint value2)
{
    // Ensure values are in 8-bit range
    value1 = value1 & 0xFF;
    value2 = value2 & 0xFF;

    // Pack into 16-bit uint, then reinterpret as half
    const uint packed = (value1 << 8) | value2;
    return asfloat(packed);
}

inline void UnpackTwoBytes(half packedValue, out uint value1, out uint value2)
{
    // Reinterpret half as 16-bit uint
    const uint packed = asuint(packedValue);

    // Extract the two bytes
    value1 = (packed >> 8) & 0xFF;
    value2 = packed & 0xFF;
}

inline float GetOccupancy(float3 PositionIn, float4 TerrainBounds, int ParcelSize)
{
    // The occupancy map has a 1 pixel border around the terrain.
    float2 scale = float2(  1.0f / (TerrainBounds.y - TerrainBounds.x + ParcelSize * 2.0f),
                            1.0f / (TerrainBounds.w - TerrainBounds.z + ParcelSize * 2.0f));

    return OccupancyTexture.SampleLevel(samplerOccupancyTexture, (PositionIn.xz - TerrainBounds.xz + ParcelSize) * scale, 0.0).r;
}


[numthreads(256, 1, 1)]
void ScatterGrass(uint3 id : SV_DispatchThreadID, uint3 groupId : SV_GroupID, uint3 localId : SV_GroupThreadID)
{
    if (groupId.x >= visibleParcelCount[0])
        return;

    PerInst perInst;

    int2 corner0 = (int2)(visibleParcels[groupId.x] * 16.0f);
    int2 gridPosition = int2((int)(localId.x % 16), (int)(localId.x / 16));

    half random_X = hash_int_to_float(corner0 + gridPosition) + gridPosition.x;
    half random_Z = hash_int_to_float(-corner0 + gridPosition) + gridPosition.y;
    float2 worldSpaceCoord = corner0 + float2(random_X, random_Z);
    float2 UV_coords = (worldSpaceCoord + 4096.0f) / 8192.0f;

    half height = HeightMapTexture.SampleLevel(samplerHeightMapTexture, UV_coords, 0).x * 4.0f;
    float fOccupancy = GetOccupancy(float3(worldSpaceCoord.x, 0.0, worldSpaceCoord.y), TerrainBounds, 16);
    height = lerp(height * TerrainHeight, 0.0, fOccupancy * 4.0);
    perInst.position = half3(random_X, height, random_Z);

    //uint rotationY = random.NextFloat(-180f, 180f);
    perInst.rotationXY = 0.0f;//PackTwoBytesIntoHalf(0, 0);
    instances[id.x] = perInst;
}
