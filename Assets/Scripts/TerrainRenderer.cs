using System.Collections.Generic;using UnityEngine;using UnityEngine.Rendering;namespace Decentraland.Terrain{    [ExecuteAlways]    public sealed class TerrainRenderer : MonoBehaviour    {        [SerializeField] private Material material;        [SerializeField] private int parcelSize = 16;        [SerializeField] private int terrainSize;        private Mesh parcelMesh;        private RenderParams renderParams;        private Matrix4x4[] instanceData;#if UNITY_EDITOR        public Mesh ParcelMesh => parcelMesh;#endif        private void OnValidate()        {#if UNITY_EDITOR            if (parcelMesh != null)            {                if (!Application.isPlaying)                    Object.DestroyImmediate(parcelMesh);                else                    Object.Destroy(parcelMesh);            }#endif            parcelMesh = CreateParcelMesh(parcelSize);            renderParams.instanceID = GetInstanceID();            renderParams.layer = gameObject.layer;            renderParams.material = material;            renderParams.receiveShadows = true;            renderParams.renderingLayerMask = RenderingLayerMask.defaultRenderingLayerMask;            renderParams.shadowCastingMode = ShadowCastingMode.On;            float terrainHalfSize = parcelSize * terrainSize * 0.5f;            renderParams.worldBounds = new Bounds(                new Vector3(0f, 2f, 0f),                new Vector3(terrainHalfSize, 4f, terrainHalfSize));            instanceData = new Matrix4x4[terrainSize * terrainSize];            for (int z = 0; z < terrainSize; z++)                for (int x = 0; x < terrainSize; x++)                    instanceData[z * terrainSize + x] = Matrix4x4.Translate(                        new Vector3(x * parcelSize - terrainHalfSize, 0f, z * parcelSize - terrainHalfSize));        }        private void OnEnable()        {            RenderPipelineManager.beginContextRendering += DrawParcels;        }        private void OnDisable()        {            RenderPipelineManager.beginContextRendering -= DrawParcels;        }        private void OnDestroy()        {            if (parcelMesh != null)            {#if UNITY_EDITOR                if (!Application.isPlaying)                    Object.DestroyImmediate(parcelMesh);                else#endif                Object.Destroy(parcelMesh);            }        }        private static Mesh CreateParcelMesh(int parcelSize)        {            var parcelMesh = new Mesh()            {                name = "Terrain Parcel",                hideFlags = HideFlags.DontSave            };            int sideVertexCount = parcelSize + 1;            var vertices = new Vector3[sideVertexCount * sideVertexCount];            for (int z = 0; z <= parcelSize; z++)                for (int x = 0; x <= parcelSize; x++)                    vertices[z * sideVertexCount + x] = new Vector3(x, 0f, z);            var triangles = new int[parcelSize * parcelSize * 6];            int index = 0;            for (int z = 0; z < parcelSize; z++)            {                for (int x = 0; x < parcelSize; x++)                {                    int start = z * sideVertexCount + x;                    triangles[index++] = start;                    triangles[index++] = start + sideVertexCount + 1;                    triangles[index++] = start + 1;                    triangles[index++] = start;                    triangles[index++] = start + sideVertexCount;                    triangles[index++] = start + sideVertexCount + 1;                }            }            var normals = new Vector3[sideVertexCount * sideVertexCount];            for (int z = 0; z <= parcelSize; z++)                for (int x = 0; x <= parcelSize; x++)                    normals[z * sideVertexCount + x] = Vector3.up;            parcelMesh.vertices = vertices;            parcelMesh.triangles = triangles;            parcelMesh.normals = normals;            parcelMesh.UploadMeshData(true);            return parcelMesh;        }        private void DrawParcels(ScriptableRenderContext context, List<Camera> cameras)        {            Graphics.RenderMeshInstanced(in renderParams, parcelMesh, 0, instanceData);        }    }}