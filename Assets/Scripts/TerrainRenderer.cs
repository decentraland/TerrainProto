using System.Collections.Generic;using UnityEngine;using UnityEngine.Rendering;using Object = UnityEngine.Object;namespace Decentraland.Terrain{    [ExecuteAlways]    public sealed class TerrainRenderer : MonoBehaviour    {        [SerializeField] private Material material;        [SerializeField] private int parcelSize = 16;        [SerializeField] private int terrainSize;        private Mesh parcelMesh;        private RenderParams renderParams;        private Matrix4x4[] instanceData;        private void OnValidate()        {#if UNITY_EDITOR            if (parcelMesh != null)            {                if (!Application.isPlaying)                    Object.DestroyImmediate(parcelMesh);                else                    Object.Destroy(parcelMesh);            }#endif            parcelMesh = CreateParcelMesh(parcelSize);            float terrainSideLength = parcelSize * terrainSize;            var worldBounds = new Bounds();            worldBounds.SetMinMax(Vector3.zero, new(terrainSideLength, 5f, terrainSideLength));            renderParams.instanceID = GetInstanceID();            renderParams.material = material;            renderParams.receiveShadows = true;            renderParams.renderingLayerMask = RenderingLayerMask.defaultRenderingLayerMask;            renderParams.shadowCastingMode = ShadowCastingMode.On;            renderParams.worldBounds = worldBounds;            instanceData = new Matrix4x4[terrainSize * terrainSize];            for (int z = 0; z < terrainSize; z++)                for (int x = 0; x < terrainSize; x++)                    instanceData[z * terrainSize + x] = Matrix4x4.Translate(                        new Vector3(x * parcelSize, 0f, z * parcelSize));        }        private void OnEnable()        {            RenderPipelineManager.beginContextRendering += DrawParcels;        }        private void OnDisable()        {            RenderPipelineManager.beginContextRendering -= DrawParcels;        }        private void OnDestroy()        {            if (parcelMesh != null)            {#if UNITY_EDITOR                if (!Application.isPlaying)                    Object.DestroyImmediate(parcelMesh);                else#endif                Object.Destroy(parcelMesh);            }        }        private static Mesh CreateParcelMesh(int parcelSize)        {            var parcelMesh = new Mesh() { hideFlags = HideFlags.DontSave };            int sideVertexCount = parcelSize + 1;            var vertices = new Vector3[sideVertexCount * sideVertexCount];            for (int z = 0; z <= parcelSize; z++)                for (int x = 0; x <= parcelSize; x++)                    vertices[z * sideVertexCount + x] = new Vector3(x, 0f, z);            var triangles = new int[parcelSize * parcelSize * 6];            int index = 0;            for (int z = 0; z < parcelSize; z++)            {                for (int x = 0; x < parcelSize; x++)                {                    int start = z * sideVertexCount + x;                    triangles[index++] = start;                    triangles[index++] = start + sideVertexCount + 1;                    triangles[index++] = start + 1;                    triangles[index++] = start;                    triangles[index++] = start + sideVertexCount;                    triangles[index++] = start + sideVertexCount + 1;                }            }            parcelMesh.vertices = vertices;            parcelMesh.triangles = triangles;            return parcelMesh;        }        private void DrawParcels(ScriptableRenderContext context, List<Camera> cameras)        {            Graphics.RenderMeshInstanced(in renderParams, parcelMesh, 0, instanceData);        }    }}